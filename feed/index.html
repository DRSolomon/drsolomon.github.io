<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Neil Solomon</title>
	<atom:link href="index.htmlfeed/" rel="self" type="application/rss+xml" />
	<link>https://OFFLINEZIP.wpsho</link>
	<description>Resume Of Neil Solomon</description>
	<lastBuildDate>Thu, 15 Aug 2019 08:36:42 +0000</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	
	<item>
		<title>Should I still learn PHP? Is it still worth it?</title>
		<link>index.html2019/08/15/should-i-still-learn-php-is-it-still-worth-it/</link>
				<pubDate>Thu, 15 Aug 2019 08:36:42 +0000</pubDate>
		<dc:creator><![CDATA[DRSolomon]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">index.html?p=511</guid>
				<description><![CDATA[Source: https://www.quora.com/Should-I-learn-PHP-in-2019-Is-it-still-worth-it Why re-write that which was already hashed out well enough, So I share that which already nicely done...]]></description>
								<content:encoded><![CDATA[
<p>Source:</p>



<p> <a href="https://www.quora.com/Should-I-learn-PHP-in-2019-Is-it-still-worth-it">https://www.quora.com/Should-I-learn-PHP-in-2019-Is-it-still-worth-it</a></p>



<p>Why re-write that which was already hashed out well enough, So I share that which already nicely done &#8211; this is not a work of my doing but a similar mindset. (Notes made by myself will so be indicated)</p>



<p>I have been using PHP since more than 6 years now. What I feel funny is how some people make fun of it. I&#8217;d rather <strong>begin with what </strong><strong><em>people say</em></strong><strong>
 are the bad parts (going by the popular opinion) and then tell how PHP 
is going to outgrow them (if it has not already done that)</strong></p>



<ol><li><strong><em>PHP is slow</em></strong>: Well, are we going to write <strong>scientific algorithms</strong>? If yes, PHP is not good. But we use PHP to <strong>present web pages</strong>.
 Given that use, PHP does a really great job at being very maintainable 
and given you have the understanding of how the web works and what 
software patterns are &#8211; PHP will serve you well for a long long time. By
 the way, Facebook takes up huge amount of load and it was written using
 PHP. Right now, they run it on HHVM which is fast and &#8216;open source&#8217;. So
 in case you feel PHP is slow, you can just start using HHVM which runs 
the PHP code much faster. By the way, right now, PHP7 is the fastest 
scripting language available in many benchmarks you can find on the web.</li><li><strong><em>PHP code is ugly</em></strong>:
 It&#8217;s quite similar to saying &#8220;C++&#8221; is ugly because you deal with 
pointers. If you don&#8217;t know what you want to do and you do not know the 
options the language provides, anything can get ugly!</li><li><strong><em>PHP has bad frameworks</em></strong>:
 Name 10 web frameworks written in node, Ruby, Python etc. and there 
would be at least 20 to counter them in PHP. Trust us when we say &#8211; 
there is no shortage of good code in PHP. Ever for WordPress, Joomla and
 Drupal (CMS frameworks) or Symfony, Yii, QCubed (development 
frameworks).</li><li><strong><em>PHP code is unmaintainable</em></strong>: How many times do we have to mention Facebook? Or Yahoo? If you know how to maintain code, <strong>PHP has got all the options</strong> right there.Just explore.</li><li><strong><em>PHP is for idiots</em></strong>: And so is Windows! And in case you are of the opinion &#8220;<em>One should not use Windows because it is too mainstream</em>&#8220;, I&#8217;d suggest &#8211; start with C++. It is best web programming language out there (and no, I&#8217;m not being sarcastic).</li><li><strong><em>PHP is only for web</em></strong>:
 This used to be a problem. Even then, if you are a newbie and do not 
know and want to learn any application programming lanaguage (I for one 
am okay with C/C++), please go learn something else because PHP does web
 and it is damn great at that. However, this is 2017, PHP is about to 
release version 7.1. Version 7.0 is already out and getting popular. If 
you want to use PHP on command line, look for <a href="http://robo.li" rel="noreferrer noopener" target="_blank">Robo</a>. If you think it cannot handle raw TCP sockets, look for <a href="https://github.com/reactphp/socket" rel="noreferrer noopener" target="_blank">React’s Socket Server</a>.
 It can read and write files, connect to databases of almost every kind,
 parse all sorts of data and there are numerous libraries and extensions
 available for most other type of work on the system. PHP is <em>no longer only for the web</em>. Explore!</li><li><strong><em>PHP is immature</em></strong>:
 There are some who say PHP is immature. They are wrong. There are two 
problems &#8211; i) PHP got tremendously popular in very short time and ii) 
PHP was not designed to be a language from ground up &#8211; so it started its
 journey on a wrong direction (<a href="https://en.wikipedia.org/wiki/PHP#Early_history" rel="noreferrer noopener" target="_blank">PHP &#8211; Wikipedia</a>).
 People who got in touch while it was immature and haven&#8217;t updated 
themselves about PHP tend to think PHP is immature. PHP today has 
everything you would want in a high-level web-programming/scripting 
language. <strong><em>Exceptions</em></strong><em>, </em><strong><em>Classes</em></strong><em>, </em><strong><em>Interfaces</em></strong><em>, </em><strong><em>Closures</em></strong><em>, </em><strong><em>Namespaces</em></strong><em>, </em><strong><em>Traits</em></strong><em> (to bring in features of multiple inheritance concepts), </em><strong><em>Generators</em></strong><em> (for facilitating co-routines) and what not!</em>
 There are many who say that PHP does not have enough features when 
compared to Python. While I am not a Python hater, there is nothing that
 PHP can’t do either. On a broader perspective, <strong>most languages with widespread popularity can do almost everything</strong>
 a regular programmer needs. Almost every language can do everything. 
Think of this &#8211; you can write server-side code, database queries, 
services and watchers using Javascript &#8211; <em>a language which was designed to run inside a browser</em>! No, PHP is not immature anymore. If you still have that ~(version 5.2) image in your head, get rid of it. PHP has moved on.</li><li><strong><em>PHP has inconsistent function names and parameter orders</em></strong>:
 What if version 7.2 gets that straight? Would you regret? There are 
many frameworks which fix that and once you are done with the basics of 
PHP, get yourself under a framework. Writing spaghetti code in PHP is 
easy (that&#8217;s both good (when you really need a damn quick fix) and bad 
(if you lose your track, you are doomed)) so you should see how 
frameworks divide the workload and organize code in PHP. Start with 
Symphony or Yii or QCubed (my favorite). Also, there is a proposal for 
fixing that consistency: <a href="https://wiki.php.net/rfc/consistent_function_names" rel="noreferrer noopener" target="_blank">rfc:consistent_function_names</a>.</li></ol>



<p>Let&#8217;s come to the reasons<strong> why you should consider PHP</strong>:</p>



<ol><li><strong><em>Damn easy to start off with</em></strong>:
 If donkeys had fingers, they would be able to write PHP. And really, 
why should you try to do the same thing in a more difficult way? If you 
do want to, go learn Java or C++. You can do wonders with them as well. 
But for starting off with web &#8211; PHP is the choice.</li><li><strong><em>Community support</em></strong>:
 Some are in the opinion that PHP grew because it was written by stupid 
for stupid. Ahem, it is running well about 75% of the web. Is that 
stupid? From small blogging platforms to great sophisticated CMS systems
 &#8211; PHP does it all. And for that reason there is a great chance that 
when you search for &#8220;how to do something in PHP&#8221; style questions &#8211; there
 would already be a great blog post written by someone on that.</li><li><strong><em>Great documentation</em></strong>:
 If you think PHP&#8217;s documentation is bad, Try reading Java or Python&#8217;s. 
Or Ruby. Every language is simple for a certain type of mindset. But a 
language which is simple for most, is actually something great (personal
 opinion). PHP is great for beginners too, because it is simple. 
[&#8220;Simplicity is sophistication&#8221; &#8211; Da Vinci]</li><li><strong><em>PHP DOES NOT lacks modern features</em></strong>:
 What modern features? I already listed some of them. Coming to client 
side &#8211; most of HTML5&#8217;s development was on JavaScript side. If you think 
you cannot write a non-blocking server (like NodeJS), consult <a href="https://github.com/reactphp/event-loop" rel="noreferrer noopener" target="_blank">React’s Event Loop</a>, or <a href="https://github.com/icicleio/icicle" rel="noreferrer noopener" target="_blank">icicle</a>,
 or other similar libraries. Since Closures are now available, you can 
write non-blocking services in PHP quite easily. Built atop these is the
 <a href="https://github.com/Devristo/phpws" rel="noreferrer noopener" target="_blank">phpws</a>
 library (and there are others, I am just listing which I am using) 
which allows you to run websockets. What modern features are we missing 
out here?</li><li><strong><em>PHP is secure</em></strong>: And which language isn&#8217;t?
 Security depends on the programmer, as much as it does on the language.
 All languages have weaknesses and points where checks can be bypassed 
and walls be broken. If I am an idiot, I&#8217;m going to write shitty 
vulnerable code in any langauge. All languages have their set of 
vulnerable points. So does PHP and like all other languages, PHP 
provides you with tools, tips and API to fend that. You need to focus on
 learning how to use it than to blame the language.</li><li><strong>PHP has strict types for parameters and return values</strong>:
 PHP, till now did not have strict data types for scalar values in 
function parameters and its functions could not promise a particular 
data type be returned. Well, now they can. PHP7 has great support for 
all of that.</li></ol>



<p>I have seen people (even on Quora) who say things like “<strong>a triple equal-to operator (===) PHP? Seriously?</strong>”.
 This sounds nothing more than a bad effect of reading too many 
click-baity (if there is such a term) articles on the web. If you have 
been even to an intermediate level of web-development and have done some
 work on Javascript, you would know that a triple-equal-to operator is 
used widely in Javascript. And if you have not worked on it yet, you do 
not know well enough about the web, yet.</p>



<p>PHP
 is not the best language to teach you about how things work. In fact, 
it teaches nothing except language-level features. If you want to learn 
web programming without getting in too much details, PHP is the best. 
But <strong>if learning about how the system (the OS, applications and 
memory) works is/was your goal, please ensure that you also learn 
something other than PHP</strong> because PHP is so damn easy, it teaches you
 almost nothing. My personal suggestion has been to learn C, C++ and 
PHP. With that set, you have almost everything covered &#8211; PHP for the 
fast moving web, C and C++ for any kind of application imaginable; or if
 you wanted to create an OS or write drivers or anything else &#8211; that set
 works well!</p>



<p>Remember
 that it is not C, C++, Java, PHP, Python, Ruby, Haskell or any of those
 stuff that you need to learn. What you need to learn is &#8216;programming&#8217;; 
to command the machine and make it do what you want. Anything works (no,
 really, it does). If your program can be written in Basic and Basic 
does the job &#8211; Basic is the language you need to learn. Fortunately, PHP
 is way more powerful. PHP wasn&#8217;t built by idiots. If it did, it&#8217;d have 
been dead by now. But look, it is the most dominant. Also, let me repeat
 it for you &#8211; just because something is easy, does not mean it is not 
powerful.</p>



<p>A 
language should ideally be consistent as well as well designed. But if 
you know about PHP’s history a bit, you would likely forgive it’s 
craziness at times (and there are some, in every single language). PHP 
was not supposed to be a full fledged language. PHP was just a small 
hack at programming a web page dynamically. It was designed for 
non-programmers in a time where C and C++ were the most popular 
languages. Even Java wasn’t really around! PHP Debuted with Java (about a
 month younger than Java) Links: <a href="https://en.wikipedia.org/wiki/PHP" rel="noreferrer noopener" target="_blank">PHP &#8211; Wikipedia</a> and <a href="https://en.wikipedia.org/wiki/Java_(programming_language)" rel="noreferrer noopener" target="_blank">Java (programming language) &#8211; Wikipedia</a>.
 It was supposed to be a light-weight scripting tool for people who were
 not serious about programming their web pages a lot. Even its creator 
Rasmus Lerdoff says that he did not intend to build a programming 
language. Instead he just wanted to write a tool for scripting web pages
 and went on adding features and it grew into a language. As such, the 
very foundation for PHP as a language is a little shaky &#8211; it is a 
language which wasn’t supposed to be one in the first place. It grew 
into a full-fledged language much later (I’d say when it reached version
 4). It matured for 10 years while it was in its 5.x era and is now 
designed reasonably well enough to compete other languages in version 7.
 Moving forward, changes become so much more difficult because there is a
 whole lot of code which depends on the features and behaviour that the 
language provides. Even then, the way PHP 7 was able to handle 
everything written in PHP 5 without causing chaos amongst us developers,
 is beautiful in itself. Ask a person who migrated from Python version 
2.x to version 3.x and you’d probably understand. Yes, there are bad 
parts in PHP’s design but understand this: the more flexibility you want
 from a language (or anything in real world), the less strict it 
becomes. PHP, in my personal opinion provides the best of both worlds &#8211; 
strict and weak; especially with version 7. You decide what parts of 
your application can be weak and which ones strict and it just adapts! 
The rest is up to the programmer.</p>



<p>Code
 is poetry. And poems are written in all languages. You need the rhythm 
and emotion more than the grammar and foresight; if you have the rhythm 
and the emotion, you can write poems in all languages of this world and 
beyond.</p>



<p><strong>EDIT:</strong>
 It&#8217;s 2015 now. But what I said still holds true! Also, reportedly PHP 7
 will have a new engine making it about 70% faster. APIs will be more 
consistent as well. A bit more of security and obviously some new 
features will be introduced. So hold tight. In the meantime, PHP has 
been running almost 80% of the web for you (check Wikipedia, the numbers
 might go a bit up and down; and by the way, Wikipedia runs on PHP too).
 Cheers.</p>



<hr class="wp-block-separator"/>



<p><strong>EDIT 2:</strong>
 It&#8217;s 2016 and PHP is still ruling. PHP 7 is significantly faster and a 
lot of people are moving their codebase to the new version. It still 
works.</p>



<hr class="wp-block-separator"/>



<p><strong>EDIT 3</strong>: It’s 2017. I have updated the answer keeping PHP 7 in mind.</p>



<hr class="wp-block-separator"/>



<p><strong>EDIT 4</strong>:
 2019 is here. The question was asked in 2014 and the person who asked 
it was afraid PHP will die. I am a little wiser having worked on Ruby on
 Rails, Java and Go too. But PHP is what I consider best for the web.</p>



<p></p>
]]></content:encoded>
										</item>
		<item>
		<title>Is Object-Oriented Programming a Trillion Dollar Disaster?</title>
		<link>index.html2019/07/24/is-object-oriented-programming-a-trillion-dollar-disaster/</link>
				<pubDate>Wed, 24 Jul 2019 06:12:39 +0000</pubDate>
		<dc:creator><![CDATA[DRSolomon]]></dc:creator>
				<category><![CDATA[Uncategorized]]></category>

		<guid isPermaLink="false">index.html?p=501</guid>
				<description><![CDATA[Is Object-Oriented Programming a Trillion Dollar Disaster? (medium.com) 736 Posted by EditorDavid on Monday July 22, 2019 @01:04AM from the...]]></description>
								<content:encoded><![CDATA[
<h2>
		

		

		
		

		

		

		

		 <a href="https://developers.slashdot.org/story/19/07/22/0426201/is-object-oriented-programming-a-trillion-dollar-disaster">Is Object-Oriented Programming a Trillion Dollar Disaster?</a> <a href="https://medium.com/better-programming/object-oriented-programming-the-trillion-dollar-disaster-%EF%B8%8F-92a4b666c7c7" target="_blank" rel="noreferrer noopener"> (medium.com) </a>

		
		
		
		

		
		
		
			<a href="https://developers.slashdot.org/story/19/07/22/0426201/is-object-oriented-programming-a-trillion-dollar-disaster#comments">736</a>
		
	</h2>



<p>Posted by    EditorDavid on Monday July 22, 2019 @01:04AM  from the OOPs dept.   Senior full-stack engineer Ilya Suzdalnitski recently published a  lively 6,000-word essay calling object-oriented programming &#8220;a trillion  dollar disaster.&#8221; <em>Precious time and brainpower are being spent thinking about  &#8220;abstractions&#8221; and &#8220;design patterns&#8221; instead of solving real-world  problems&#8230;   Object-Oriented Programming (OOP) has been created with  one goal in mind &#8212; to manage the complexity of procedural codebases. In other words, it was supposed to improve code organization. There&#8217;s <a href="https://medium.com/better-programming/object-oriented-programming-the-trillion-dollar-disaster-%EF%B8%8F-92a4b666c7c7">no objective and open evidence that OOP is better than plain procedural programming</a>&#8230; Instead of reducing complexity, it encourages promiscuous sharing of mutable state and introduces additional complexity with its numerous design patterns. OOP makes common development practices, like refactoring and testing, needlessly hard&#8230;<br> <br> Using OOP is seemingly innocent in the short-term, especially on greenfield projects. But what are the long-term  consequences of using OOP? OOP is a time bomb, set to explode sometime  in the future when the codebase gets big enough.  Projects get delayed,  deadlines get missed, developers get burned-out, adding in new features  becomes next to impossible. The organization labels the codebase as the &#8220;legacy codebase&#8221;, and the development team plans a rewrite&#8230;.   OOP provides developers too many tools and choices, without imposing  the right kinds of limitations. Even though OOP promises to address  modularity and improve reusability, it fails to deliver on its  promises&#8230; <br> <br> I&#8217;m not criticizing Alan Kay&#8217;s OOP &#8212; he is a genius. I wish OOP was  implemented the way he designed it. I&#8217;m criticizing the modern Java/C#  approach to OOP&#8230;  I think that it is plain wrong that OOP is  considered the de-facto standard for code organization by many people,  including those in very senior technical positions. It is also wrong  that many mainstream languages don&#8217;t offer any other alternatives to  code organization other than OOP.</em><br> The essay ultimately blames Java for the popularity of OOP, citing Alan  Kay&#8217;s comment that Java &#8220;is the most distressing thing to happen to  computing since MS-DOS.&#8221;  It also quotes Linus Torvalds&#8217;s observation  that &#8220;limiting your project to C means that people don&#8217;t screw things up  with any idiotic &#8216;object model&#8217;.&#8221;<br><br> And it ultimately suggests Functional Programming as a superior alternative, making the following assertions about OOP: </p>



<ul><li>&#8220;OOP code encourages the use of shared mutable state, which has
 been proven to be unsafe time and time again&#8230; [E]ncapsulation, in 
fact, is glorified global state.&#8221;</li><li>&#8220;OOP typically requires a lot of boilerplate code (low signal-to-noise ratio).&#8221;</li><li>&#8220;Some
 might disagree, but OOP code is notoriously difficult to unit test&#8230; 
[R]efactoring OOP code is really hard without dedicated tools like 
Resharper.&#8221;</li><li>&#8220;It is impossible to write good and maintainable Object-Oriented code.&#8221;</li></ul>
]]></content:encoded>
										</item>
		<item>
		<title>Things we have learned in software development</title>
		<link>index.html2018/04/16/things-we-have-learned-in-software-development/</link>
				<pubDate>Mon, 16 Apr 2018 20:34:17 +0000</pubDate>
		<dc:creator><![CDATA[DRSolomon]]></dc:creator>
				<category><![CDATA[Thoughts]]></category>
		<category><![CDATA[code]]></category>
		<category><![CDATA[design]]></category>
		<category><![CDATA[document]]></category>
		<category><![CDATA[html]]></category>
		<category><![CDATA[php]]></category>
		<category><![CDATA[plugin]]></category>
		<category><![CDATA[web]]></category>

		<guid isPermaLink="false">https://ryan-demo.beshley.com/?p=115</guid>
				<description><![CDATA[Random thoughts on coding and development.]]></description>
								<content:encoded><![CDATA[<p>&#8220;Without requirements or design, programming is the art of adding bugs to an empty text file.&#8221; &#8212; Louis Srygley</p>
<p>&#8220;A language that doesn&#8217;t affect the way you think about programming, is not worth knowing.&#8221; &#8212; Alan Perlis</p>
<h3 id="write-steps-as-comments">Write steps as comments</h3>
<p>If you have no idea how to start, describe the intended flow of the application in high level, pure English first. Then fill the spaces between comments with the code.</p>
<p>Better yet: think of every comment as a function, then write the function that does exactly what you wrote.</p>
<h3 id="documentation-is-a-love-letter-to-your-future-self">Documentation is a love letter to your future self</h3>
<p>We all know writing those `<em>bladdy damn docs</em>` for functions, classes and modules are a pain in the backside. But realizing what you were thinking when you wrote the function will save you much time in the future.</p>
<h3 id="be-ready-to-throw-your-code-away">Be ready to throw your code away</h3>
<p>You shouldn&#8217;t worry about doing this.</p>
<p>Your code is not a brick wall: if you have to throw it always, it is not wasted code. It only means your time writing code was lost, but you got have a better understanding of the problem now!</p>
<h3 id="right-tool-for-the-job-is-just-to-push-an-agenda">&#8220;The right tool for the job&#8221; is just used to push an agenda</h3>
<p>&#8220;The right tool for the job&#8221; should be an expression that meant that there is a right and a wrong tool to do something &#8212; e.g., using a certain language or framework instead of the current language or framework.</p>
<p>Every time I heard someone mention it, they were trying to push their personal favorite language or framework instead of, lets say, the right language or framework.</p>
<h3 id="data-flows-beat-patterns">Flows beat patterns</h3>
<p>When you understand how the data must flow in your code, you&#8217;ll end up with better code than if you applied a bunch of design patterns&#8230; Personal opinion!</p>
<h3 id="the-magical-number-seven-plus-or-minus-two">The Magical Number Seven, Plus or Minus Two</h3>
<p>&#8220;<a href="https://en.wikipedia.org/wiki/The_Magical_Number_Seven,_Plus_or_Minus_Two">The magical number</a>&#8221; is a psychology article about the number of things one can keep in their mind at the same time.</p>
<p>If you have a function, that calls a function, that calls a function, that calls a function, that calls a function, that calls function, you may be sure it will be a hell to read later.</p>
<p>Think more about: I&#8217;ll get the result of this function, then pass it to the second function, get its result, pass to the third and so on.</p>
<p>But:</p>
<ol>
<li>Today, psychologists talk more about the magical number FOUR, not seven.</li>
<li>Think function composition (as in &#8220;I&#8217;ll call that function, then that function, then that function&#8230;&#8221;), not function calling (as in &#8220;That function will call that function, that will call that function&#8230;&#8221;).</li>
</ol>
<h3 id="code-reviews-are-not-for-style">Code reviews are not for style</h3>
<p>Take your time on code or peer reviews to point architectural or design problems, not the code style problems.</p>
<p>Nobody really likes the person whose code or peer reviews are only <em>&#8220;you left blanks in this line&#8221;</em> or &#8220;missing space before parenthesis&#8221; and such.</p>
<p>Now, if you <strong><em>do</em></strong> find architectural or design problems, <strong><em>then</em></strong> you can add your code style problems.</p>
<h3 id="companies-look-for-specialists-but-keep-generalists-longer">Companies look for specialists but keep generalists longer</h3>
<p>If you know a lot about one single language, it may make it easier to get a job, but in the long run, language usage dies and you&#8217;ll need to find something else. Knowing a bit about a many other languages helps in the long run, not to mention that it may help you think of better solutions.</p>
<h3 id="when-it-s-time-to-stop-it-s-time-to-stop">When it&#8217;s time to stop, it&#8217;s time to stop</h3>
<p>Learn when you can&#8217;t code anymore.</p>
<p>Learn when you can&#8217;t process things anymore. Don&#8217;t push beyond that, it will just make things worse in the future.</p>
<p>If you don&#8217;t stop when you can&#8217;t carry on comfortably you will write junk, and likely have to re-do it tomorrow!</p>
]]></content:encoded>
										</item>
	</channel>
</rss>
